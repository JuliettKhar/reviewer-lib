// https://platform.openai.com/docs/deprecations
import OpenAI from 'openai';
import {exec} from 'child_process';
import {
    generateCodeStyleRecommendationsPrompt,
    generateDocumentationPrompt, generateHistoricalAnalysisPrompt,
    generateOptimizeCodePrompt,
    generateSecurityAnalysisPrompt,
    generateSubmitCodeAssistanceModePrompt,
    generateSubmitCodePrompt,
    generateTestsPrompt
} from "./utils/prompts";
import { defaultOptions } from './utils/default-options';

interface IModel {
    id: string;
    object: string;
    created: number;
    owned_by: string;
}

interface IDefaultOptions  {
    temperature: number;
    top_p: number;
    frequency_penalty: number;
    presence_penalty: number;
    n: number;
    best_of: number;
    logprobs: null;
    echo: boolean;
    stop?: string[];
}


class Reviewer {
    private readonly apiKey;
    private readonly model;
    private readonly client;
    private readonly maxTokens;
    private readonly modelOptions;

    constructor(apiKey: string, model = 'gpt-3.5-turbo-instruct', maxTokens = 400, defaultClassOptions: IDefaultOptions = defaultOptions) {
        this.apiKey = apiKey;
        this.model = model;
        this.maxTokens = maxTokens;
        this.modelOptions = defaultClassOptions

        this.client = new OpenAI({
            apiKey: this.apiKey,
        });
    }

    async submitCode(code: string): Promise<string | undefined> {
        try {
            const response: any = await this.client.post(`/engines/${this.model}/completions`, {
                body: {
                    prompt: generateSubmitCodePrompt(code),
                    max_tokens: this.maxTokens,
                },
            });

            return response.choices[0].text;
        } catch (error: Error | any) {
            console.info('Request available models by getCurrentModels()');
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }

    async submitCodeAssistanceMode(code: string): Promise<string | undefined> {
        try {
            const response: any = await this.client.completions.create({
                prompt: generateSubmitCodeAssistanceModePrompt(code),
                model: this.model,
                max_tokens: this.maxTokens,
                ...this.modelOptions,
            });

            return response.choices[0].text;
        } catch (error: Error | any) {
            console.info('Request available models by getCurrentModels()');
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }

    async getCurrentModels(): Promise<IModel[]> {
        try {
            const {data}: { data: IModel[] } = await this.client.get('/models');
            return data;
        } catch (error: Error | any) {
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }

    async codeReviewOnCI() {
        exec(`
            git fetch origin
            git diff origin/develop -- . ':!package-lock.json' ':!tsconfig.json' ':!dist/' > pr.diff
        `, async (err, stdout, stderr) => {
            if (err) {
                console.error(`Error executing git diff: ${stderr}`);
                return new Error(String(err));
            }

            const feedback = await this.submitCode(stdout);
            console.info('Code Review-ci Feedback:', feedback);
            return feedback;
        });
    }

    async generateDocumentation(code: string): Promise<string> {
        try {
            const response = await this.client.completions.create({
                prompt: generateDocumentationPrompt(code),
                model: this.model,
                ...this.modelOptions,
                max_tokens: this.maxTokens,
                temperature: 0.5,
                n: 1,
                stop: ["*/"]
            });

            if (response.choices && response.choices.length > 0) {
                let documentation = response.choices[0].text;

                if (!documentation.startsWith('/**')) {
                    documentation = `/**\n${documentation}`;
                }

                if (!documentation.endsWith('*/')) {
                    documentation = `${documentation}\n*/`;
                }

                return documentation
            } else {
                return 'No documentation generated by OpenAI API';
            }
        } catch (error: Error | unknown | any) {
            throw new Error(`OpenAI API error: ${error.message || error}`);
        }
    }

    async optimizeCode(code: string): Promise<string> {
        try {
            const response = await this.client.completions.create({
                prompt: generateOptimizeCodePrompt(code),
                model: this.model,
                max_tokens: this.maxTokens,
                ...this.modelOptions,
            });

            return response.choices[0].text;
        } catch (error: Error | any) {
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }

    async generateTests(code: string): Promise<string> {
        try {
            const response = await this.client.completions.create({
                prompt: generateTestsPrompt(code),
                model: this.model,
                max_tokens: this.maxTokens,
                ...this.modelOptions,
                temperature: 0.5,
                n: 1,
            });
            return response.choices[0].text;
        } catch (error: Error | any) {
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }

    async securityAnalysis(code: string): Promise<string> {
        try {
            const response = await this.client.completions.create({
                prompt:generateSecurityAnalysisPrompt(code),
                model: this.model,
                max_tokens: this.maxTokens,
                ...this.modelOptions,
            });
            return response.choices[0].text;
        } catch (error: Error | any) {
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }

    async codeStyleRecommendations(code: string): Promise<string> {
        try {
            const response = await this.client.completions.create({
                prompt: generateCodeStyleRecommendationsPrompt(code),
                model: this.model,
                max_tokens: this.maxTokens,
                ...this.modelOptions,
                temperature: 0.5,
                n: 1,
            });
            return response.choices[0].text;
        } catch (error: Error | any) {
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }

    async historicalAnalysis(repoPathOrDiff: string): Promise<string> {
        try {
            const response = await this.client.completions.create({
                prompt: generateHistoricalAnalysisPrompt(repoPathOrDiff),
                model: this.model,
                max_tokens: this.maxTokens,
                ...this.modelOptions,
                temperature: 0.5,
                n: 1,
            });
            return response.choices[0].text;
        } catch (error: Error | any) {
            throw new Error(`OpenAI API error: ${error.message}`);
        }
    }
}

export {
    Reviewer
};